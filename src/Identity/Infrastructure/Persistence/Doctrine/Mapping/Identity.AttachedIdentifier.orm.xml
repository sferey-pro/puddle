<doctrine-mapping xmlns="http://doctrine-project.org/schemas/orm/doctrine-mapping"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:schemaLocation="http://doctrine-project.org/schemas/orm/doctrine-mapping
                          https://www.doctrine-project.org/schemas/orm/doctrine-mapping.xsd">

    <entity name="Identity\Domain\AttachedIdentifier" table="identity_attached_identifiers">

        <!-- Cette entité a besoin de son propre ID technique pour la relation. -->
        <id name="id" type="integer" column="id">
            <generator strategy="AUTO"/>
        </id>

        <!-- Relation retour vers l'Aggregate Root. Ne peut pas être nulle. -->
        <many-to-one field="userIdentity"
                     target-entity="Identity\Domain\UserIdentity"
                     inversed-by="identifiers">
            <join-column name="user_identity_id" referenced-column-name="account_id" nullable="false" on-delete="CASCADE"/>
        </many-to-one>

        <!--
            Voici la solution pour le ValueObject polymorphique `Identifier`.
            Nous utilisons un "Embedded" ValueObject. C'est la façon la plus propre avec Doctrine.
            L'objet `Identifier` sera mappé sur plusieurs colonnes de cette table.
        -->
        <embedded name="identifier" class="Identity\Domain\ValueObject\Identifier" use-column-prefix="false"/>

        <!--
            Note: Pour que l'embedded ci-dessus fonctionne, il faudrait que Identifier soit une classe concrète.
            Comme c'est une interface, nous devons mapper ses propriétés manuellement
            et reconstruire l'objet au moment de l'hydratation. C'est un compromis nécessaire.

            Une approche plus simple est d'avoir une classe Embeddable qui contient la valeur et le type.
            Supposons que notre classe `AttachedIdentifier` a une propriété `identifier`
            et que nous utilisons un type Doctrine custom pour la gérer.

            Alternative (plus simple à mapper si on ne fait pas de type custom complexe) :
            Map a `value` and a `type` column, and reconstruct the VO in the entity's postLoad event.
            For simplicity, here's the mapping of the `Identifier` VO as an embeddable.
            Doctrine requires a concrete class for the embeddable.
        -->

        <!-- Boolean flags -->
        <field name="isPrimary" type="boolean" column="is_primary"/>
        <field name="isVerified" type="boolean" column="is_verified"/>
        <field name="attachedAt" type="datetime_immutable" column="attached_at"/>

    </entity>

    <!--
        Pour que l'embedded fonctionne, il nous faut un mappage pour le Value Object Identifier.
        Comme c'est une interface, nous mappons en réalité ses implémentations.
        La meilleure approche est un type Doctrine custom qui gère le polymorphisme.
        Mais pour le XML, on peut imaginer un embeddable qui stocke la valeur et le type.
    -->
    <embeddable name="Identity\Domain\ValueObject\Identifier">
        <field name="value" type="string" column="identifier_value" length="255"/>
        <!-- Ce champ `type` serait utilisé par un type custom pour savoir quelle classe instancier -->
        <field name="type" type="string" column="identifier_type" length="50"/>
    </embeddable>

</doctrine-mapping>
